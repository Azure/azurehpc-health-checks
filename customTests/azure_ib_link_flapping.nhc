#!/bin/bash

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/azure_common.nhc"

#expect to not have any IB link flaps within a given time interval (in hours)
IB_FLAPPING_LINK_TEST="IB link flapping detected"

function get_linkflap_count(){
   local log_file="$1"
   local start_time="$2"
   local now="$3"

   # AWK script for processing log entries
   local awk_script='
   BEGIN {
       split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", m);
       for (i=1; i<=12; i++) month[m[i]] = i;
   }
   {
       if (match($0, /ib[0-9a-zA-Z_]+/)) {
           log_month = $1;
           log_day = $2;
           log_time = $3;

           if (length(log_day) == 1) log_day = "0" log_day;

           # Try both current and previous year
           current_year = strftime("%Y", now)
           previous_year = current_year - 1

           # Construct timestamp for current year
           ts1 = mktime(current_year " " month[log_month] " " log_day " " substr(log_time, 1, 2) " " substr(log_time, 4, 2) " " substr(log_time, 7, 2))

           # Construct timestamp for previous year
           ts2 = mktime(previous_year " " month[log_month] " " log_day " " substr(log_time, 1, 2) " " substr(log_time, 4, 2) " " substr(log_time, 7, 2))

           # Compute which is closer to now
           delta1 = (ts1 > now) ? ts1 - now : now - ts1
           delta2 = (ts2 > now) ? ts2 - now : now - ts2

           log_ts = (delta1 <= delta2) ? ts1 : ts2

           if (log_ts >= start && log_ts <= now) {
               # Extract device name (e.g., ib0, ib1, ibP264s182277, etc.)
               if (match($0, /ib[0-9a-zA-Z_]+/)) {
                   dev = substr($0, RSTART, RLENGTH)
                   if (dev != "") {
                       count[dev]++
                   }
               }
           }
       }
   }
   END {
       for (d in count)
           print count[d], d;
   }'

   if [[ "$log_file" == *.gz ]]; then
      # Handle compressed files with zcat
      awk_file_counts=$(zcat "$log_file" 2>/dev/null | grep -i 'lost carrier' | awk -v now="$now" -v start="$start_time" "$awk_script")
   else
      # Handle regular files
      awk_file_counts=$(grep -i 'lost carrier' "$log_file" | awk -v now="$now" -v start="$start_time" "$awk_script")
      # dbg "File counts for $log_file: $awk_file_counts"
   fi
}


function check_ib_link_flapping() {
   local TIME_INTERVAL_HOURS=${1:-24}
   local IB_LINK_FLAP_THRESHOLD="${2:-5}"
   dbg "HELP"
         # die "check_ib_link_flapping"

   # Remaining arguments are log files
   shift 2
   local log_files=("$@")
   
   # If no log files specified, use default
   if [[ ${#log_files[@]} -eq 0 ]]; then
      log_files=("$AZ_NHC_ROOT/syslog")
   fi
   
   # Check each log file exists and warn if not
   local valid_log_files=()
   for log_file in "${log_files[@]}"; do
      if [[ -f "$log_file" ]]; then
         valid_log_files+=("$log_file")
      else
         log "$FUNCNAME: Warning - log file $log_file not found, skipping"
      fi
   done

   if [[ ${#valid_log_files[@]} -eq 0 ]]; then
      log "$FUNCNAME: No valid log files found. IB Link flapping test skipped."
      return 0
   fi

   dbg "$FUNCNAME: Checking log files: ${valid_log_files[*]}"

   # Calculate start time in epoch
   local start_time=$(date -d "$TIME_INTERVAL_HOURS hours ago" +%s)
   local now=$(date +%s)
      pass 0 "$FUNCNAME: No excessive IB link flapping found"

   # Count lost carrier events per device across all log files
   local device_counts=""
   for log_file in "${valid_log_files[@]}"; do
      local file_counts=""

      # Get Device Counts
      get_linkflap_count "$log_file" "$start_time" "$now"
      file_counts="$awk_file_counts"

      # Combine counts from this file with overall counts
      if [[ -n "$file_counts" ]]; then
         if [[ -z "$device_counts" ]]; then
            device_counts="$file_counts"
         else
            # Merge counts from multiple files
            device_counts=$(echo -e "$device_counts\n$file_counts" | awk '
            {
               device_count[$2] += $1
            }
            END {
               for (d in device_count)
                  print device_count[d], d;
            }
            ')
         fi
      fi
   done

   # Sort the final results
   device_counts=$(echo "$device_counts" | sort -nr)

   dbg "Raw awk output: $device_counts"
   # Check if any device exceeds threshold
   has_flapping=0
   flapping_devices=""
   
   while read -r count device; do
      if [[ -n "$count" ]] && [[ -n "$device" ]]; then
         dbg "Device $device had $count link flap events in the last $TIME_INTERVAL_HOURS hours"
         if [[ $count -ge $IB_LINK_FLAP_THRESHOLD ]]; then
            has_flapping=1
            if [[ -n "$flapping_devices" ]]; then
               flapping_devices="$flapping_devices, "
            fi
            flapping_devices="${flapping_devices}${device}($count)"
         fi
      fi
   done <<< "$device_counts"
   
   if [[ $has_flapping -eq 1 ]]; then
      log "$IB_FLAPPING_LINK_TEST: Devices with excessive link flapping (>=$IB_LINK_FLAP_THRESHOLD events in $TIME_INTERVAL_HOURS hours): $flapping_devices"
      die 1 "$FUNCNAME: $IB_FLAPPING_LINK_TEST. Devices: $flapping_devices. FaultCode: NHC2005"
   else
      log "No IB devices exceeded link flap threshold ($IB_LINK_FLAP_THRESHOLD) in the last $TIME_INTERVAL_HOURS hours"
      pass 0 "$FUNCNAME: No excessive IB link flapping found"
   fi
   
   return 0
}
