#!/bin/bash

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/azure_common.nhc"

#expect to not have any IB link flaps within a given time interval (in hours)
IB_FLAPPING_LINK_TEST="IB link flapping detected"

function check_ib_link_flapping() {
   local TIME_INTERVAL_HOURS=${1:-24}
   local LOG_PATH=${2:-"$AZ_NHC_ROOT/syslog"}
   local IB_LINK_FLAP_THRESHOLD="${3:-5}"

   if [[ ! -f $LOG_PATH ]]; then
      log "$FUNCNAME: kernel log $LOG_PATH not found. IB Link flapping test skipped."
      return 0
   fi

   # Calculate start time in epoch
   local start_time=$(date -d "$TIME_INTERVAL_HOURS hours ago" +%s)
   local now=$(date +%s)
   
   # Count lost carrier events per device
   local device_counts=$(awk -v now="$now" -v start="$start_time" -v log_path="$LOG_PATH" '
   BEGIN {
       split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", m);
       for (i=1; i<=12; i++) month[m[i]] = i;
   }
   {
       if (tolower($0) ~ /ib[0-9a-zA-Z_]+.*lost carrier/) {
           log_month = $1;
           log_day = $2;
           log_time = $3;

           if (length(log_day) == 1) log_day = "0" log_day;

           # Try both current and previous year
           current_year = strftime("%Y", now)
           previous_year = current_year - 1

           # Timestamp for current year
           # Construct timestamp for current year
           ts1 = mktime(current_year " " month[log_month] " " log_day " " substr(log_time, 1, 2) " " substr(log_time, 4, 2) " " substr(log_time, 7, 2))

           # Construct timestamp for previous year
           ts2 = mktime(previous_year " " month[log_month] " " log_day " " substr(log_time, 1, 2) " " substr(log_time, 4, 2) " " substr(log_time, 7, 2))

           # Compute which is closer to now
           delta1 = (ts1 > now) ? ts1 - now : now - ts1
           delta2 = (ts2 > now) ? ts2 - now : now - ts2

           log_ts = (delta1 <= delta2) ? ts1 : ts2

           if (log_ts >= start && log_ts <= now) {
               # Extract device name (e.g., ib0, ib1, ibP264s182277, etc.)
               match($0, /ib[0-9a-zA-Z_]+/, dev)
               if (dev[0] != "") {
                   count[dev[0]]++
               }
           }
       }
   }
   END {
       for (d in count)
           print count[d], d;
   }
   ' | sort -nr)

   dbg "Raw awk output: $device_counts"
   # Check if any device exceeds threshold
   has_flapping=0
   flapping_devices=""
   
   while read -r count device; do
      if [[ -n "$count" ]] && [[ -n "$device" ]]; then
         dbg "Device $device had $count link flap events in the last $TIME_INTERVAL_HOURS hours"
         if [[ $count -ge $IB_LINK_FLAP_THRESHOLD ]]; then
            has_flapping=1
            if [[ -n "$flapping_devices" ]]; then
               flapping_devices="$flapping_devices, "
            fi
            flapping_devices="${flapping_devices}${device}($count)"
         fi
      fi
   done <<< "$device_counts"
   
   if [[ $has_flapping -eq 1 ]]; then
      log "$IB_FLAPPING_LINK_TEST: Devices with excessive link flapping (>=$IB_LINK_FLAP_THRESHOLD events in $TIME_INTERVAL_HOURS hours): $flapping_devices"
      die 1 "$FUNCNAME: $IB_FLAPPING_LINK_TEST. Devices: $flapping_devices. FaultCode: NHC2005"
   else
      log "No IB devices exceeded link flap threshold ($IB_LINK_FLAP_THRESHOLD) in the last $TIME_INTERVAL_HOURS hours"
      pass 0 "$FUNCNAME: No excessive IB link flapping found"
   fi
   
   return 0
}
